#!/usr/bin/env node
import { getConfig, saveConfig } from "./repoConfig.js";
import { writeFile } from "node:fs/promises";
import packageManeger, { packageSave } from "./packagesData.js";
import cluster from "node:cluster";
import inquirer from "inquirer";
import openpgp from "openpgp";
import yargs from "yargs";
import https from "node:https";
import path from "node:path";
import repo from "./express_route.js";
import yaml from "yaml";
import os from "node:os";
import ora from "ora";

yargs(process.argv.slice(2)).version(false).help().demandCommand().strictCommands().alias("h", "help").option("cofig-path", {
  type: "string",
  default: path.join(process.cwd(), "repoconfig.yml"),
  alias: "c",
  demandOption: false,
  description: "Default config path"
}).command("config", "maneger basics configs", async yargs => {
  return yargs.demandCommand().strictCommands().command("pgp_keys", "Generate PGP keys", async yargs => {
    const options = yargs.option("passphrase", {
      type: "string",
      default: "",
      alias: "p",
      demandOption: false,
    }).option("name", {
      type: "string",
      default: "",
      alias: "n",
      demandOption: true,
      description: "You name to register in PGP key"
    }).option("email", {
      type: "string",
      default: "",
      alias: "e",
      demandOption: true,
      description: "You email to register in PGP key"
    }).parseSync();

    const config = await getConfig(options.cofigPath);
    if (!options.email) throw new Error("email is required");
    if (!options.name) throw new Error("name is required");
    if (!options.passphrase) options.passphrase = undefined;
    const privatePath = path.resolve(path.dirname(options.cofigPath), "private.key");
    const publicPath = path.resolve(path.dirname(options.cofigPath), "public.key");
    const keys = await openpgp.generateKey({
      rsaBits: 4096,
      format: "armored",
      type: "rsa",
      passphrase: options.passphrase,
      userIDs: [{
        name: options.name,
        email: options.email,
        comment: "Generated by apt-stream"
      }],
    });
    if (!config["apt-config"]) config["apt-config"] = {};
    await writeFile(privatePath, keys.privateKey);
    await writeFile(publicPath, keys.publicKey);
    config["apt-config"].pgpKey = {passphrase: options.passphrase, private: privatePath, public: publicPath};
    console.log("PGP keys generated");
    // Private key
    console.log("Private Key:\n%s\n", keys.privateKey);
    // Public key
    console.log("Public Key:\n%s", keys.publicKey);
    await saveConfig(options.cofigPath, config);
    console.log("Config saved in '%s'", options.cofigPath);
  }).command("convert_to_base64", "Convert config to base64 to export to env or backup", async yargs => {
    const options = yargs.option("json", {
      type: "boolean",
      default: true,
      alias: "j",
      demandOption: false,
      description: "Output as JSON",
    }).option("yaml", {
      type: "boolean",
      default: false,
      alias: "y",
      demandOption: false,
      description: "Output as YAML",
    }).option("output", {
      type: "string",
      default: "",
      alias: "o",
      demandOption: false,
      description: "Save to file",
    }).parseSync();
    const config = await getConfig(options.cofigPath);
    const base64 = Buffer.from(options.json ? JSON.stringify(config) : yaml.stringify(config)).toString("base64");
    if (options.output) return writeFile(options.output, "base64:"+base64).then(() => console.log("Saved to '%s'", options.output));
    console.log("base64:%s", base64);
  });
}).command("server", "Run HTTP serber", async yargs => {
  const options = yargs.option("cpus", {
    type: "number",
    default: os.cpus().length/2,
    alias: "C",
    demandOption: false,
    description: "Number of cpus to use in Cluster"
  }).option("disable_package_load", {
    type: "boolean",
    default: false,
    alias: "D",
    demandOption: false,
    description: "Disable package load if database configured"
  }).parseSync();
  process.on("unhandledRejection", err => console.error(err));
  process.on("uncaughtException", err => console.error(err));
  const { app, packageConfig, packageManeger } = await repo(Object.keys(process.env).find(key => key.startsWith("APT_STREAM")) ? `env:${Object.keys(process.env).find(key => key.startsWith("APT_STREAM"))}` : options.cofigPath);
  app.all("*", ({res}) => res.status(404).json({
    error: "Endpoint not exists",
    message: "Endpoint not exists, check the documentation for more information"
  }));
  app.use((err, {}, res, {}) => {
    console.error(err);
    const stack: string = err?.stack ?? "No stack";
    res.status(400).json({
      error: "Internal Server Error",
      message: "There was an error on our part, sorry for the inconvenience",
      stack: {
        forUser: "Create issue in apt-stream repository (https://github.com/Sirherobrine23/apt-stream/issues) with value of 'forDeveloper'",
        forDeveloper: stack
      },
    });
  });
  const port = process.env.PORT ?? packageConfig["apt-config"]?.portListen ?? 3000;
  const portListen = (message: string) => {
    const httpsConfig = packageConfig["apt-config"]?.https;
    if (httpsConfig?.ca && httpsConfig?.key) {
      https.createServer({
        ca: httpsConfig.ca,
        key: httpsConfig.key,
      }, app).listen(port, function() {console.log(message, this.address()?.port);});
    } else app.listen(port, function() {console.log(message, this.address()?.port);});
  }
  if (options.cpus > 1) {
    if (cluster.isWorker) {
      console.log("Worker %d running, PID: %f", cluster.worker?.id ?? "No ID", process.pid);
      portListen("Work apt Stream Port listen on %f");
      return;
    }
    console.log("Work master, PID %f, starting workers ...", process.pid);
    for (let i = 0; i < options.cpus; i++) cluster.fork({...process.env, workNumber: i});
    cluster.on("error", err => {
      console.log(err?.stack ?? String(err));
      // process.exit(1);
    }).on("exit", (worker, code, signal: NodeJS.Signals) => {
      // if (process[Symbol.for("ts-node.register.instance")]) cluster.setupPrimary({/* Fix for ts-node */ execArgv: ["--loader", "ts-node/esm"]});
      if (signal === "SIGKILL") return console.log("Worker %d was killed", worker?.id ?? "No ID");
      else if (signal === "SIGABRT") return console.log("Worker %d was aborted", worker?.id ?? "No ID");
      else if (signal === "SIGTERM") return console.log("Worker %d was terminated", worker?.id ?? "No ID");
      console.log("Worker %d died with code: %s, Signal: %s", worker?.id ?? "No ID", code, signal ?? "No Signal");
      cluster.fork();
    });
  } else {
    console.warn("Running without cluster, this is not recommended for production");
    portListen("Apt Stream Port listen on %f");
  }

  if (options.disable_package_load) {
    if (packageConfig["apt-config"]?.mongodb?.uri) return;
    console.warn("Loadind package, database not configured");
  }
  for (const distName in packageConfig.repositories) {
    const dist = packageConfig.repositories[distName];
    for (const target of dist.targets) await packageManeger.loadRepository(distName, target, packageConfig["apt-config"], packageConfig);
  }
}).command("packages", "Maneger packages in Database", async yargs => yargs.demandCommand().strictCommands().command("show", "List add packages", async yargs => {
  const options = yargs.parseSync();
  const pack = await packageManeger(await getConfig(options.cofigPath));
  const packages = await pack.getPackages();
  for (const { control, suite, dist } of packages) console.log("\nPackage: %s/%s\n\tArchicture: %s\n\tDistribuition: %s\n\tComponent: %s", control.Package, control.Version, control.Architecture, dist, suite);
  return pack.close();
}).command("load", "Update or add new packages to Database", async yargs => {
  const options = yargs.option("cleanDB", {
    type: "boolean",
    demandOption: false,
    description: "Delete all packages in database",
    default: false
  }).parseSync();
  const packageConfig = await getConfig(options.cofigPath);
  const pack = await packageManeger({...packageConfig, "apt-config": {mongodb: {dropCollention: !!options.cleanDB}}}, {dontReturnError: true, showPackagesModifications: true});
  for (const distName in packageConfig.repositories) {
    const dist = packageConfig.repositories[distName];
    for (const target of dist.targets) await pack.loadRepository(distName, target, packageConfig["apt-config"], packageConfig);
  }
  return pack.close();
}).command("edit", "Edit packages interactive", async yargs => {
  const options = yargs.option("distribuition", {
    type: "string",
    alias: "d",
    demandOption: false,
    description: "Distribution to edit"
  }).option("cleanDB", {
    type: "boolean",
    demandOption: false,
    description: "Delete all packages in database",
    default: false
  }).parseSync();
  const packageConfig = await getConfig(options.cofigPath);
  const pack = await packageManeger({"apt-config": {...packageConfig, mongodb: {dropCollention: !!options.cleanDB}}}, {dontReturnError: false, showPackagesModifications: true});
  if (!!options.cleanDB) {
    console.log("Cleaning database");
    return pack.close();
  }
  async function packEdit(dist?: string) {
    dist = dist ?? options.distribuition ?? (await inquirer.prompt({choices: await pack.getDists(), message: "Select distribuition", name: "dist", type: "list"})).dist;
    const oraLoadPackages = ora("Loading packages").start();
    const packages = await pack.getPackages(dist);
    const reducePackages = packages.reduce((prev, data) => {
      if (!prev[data.control.Package]) prev[data.control.Package] = [];
      prev[data.control.Package].push(data);
      return prev;
    }, {} as {[packageName: string]: packageSave[]});
    oraLoadPackages.succeed("Loaded packages");
    const packageSelect = await inquirer.prompt({choices: Object.keys(reducePackages), message: "Select package", name: "package", type: "list"});
    console.log("Package: %s", packageSelect.package);
    const packagesArray = reducePackages[packageSelect.package];
    const packagesIndex: number[] = await inquirer.prompt({
      type: "checkbox",
      name: "packages",
      message: "Select packages",
      choices: packagesArray.map((data, index) => ({name: `${data.control.Version} (${data.control.Architecture})`, value: index}))
    }).then(x => x.packages);
    if (!packagesIndex.length) return ora("No valid package selected").fail();
    for (const packIndex of packagesIndex) {
      const packData = packagesArray[packIndex];
      if (!packData) return console.log("No valid package selected");
      const action: "remove"|"edit"|"cancel" = await inquirer.prompt({
        type: "list",
        name: "action",
        message: "Select action",
        choices: [
          {name: "Remove", value: "remove"},
          {name: "Edit", value: "edit"},
          {name: "Cancel", value: "cancel"}
        ]
      }).then(x => x.action);
      if (action === "cancel") {
        await ora("Canceled, no changes").fail();
        continue;
      } else if (action === "remove") {
        const confirm = await inquirer.prompt({
          type: "confirm",
          name: "confirm",
          message: "Are you sure you want to remove this package?"
        }).then(x => x.confirm);
        if (!confirm) {
          console.log("Canceled, no changes");
          continue;
        }
        await pack.deletePackage(packData);
        console.log("Removed package");
        continue;
      } else if (action === "edit") {
        const editData = await inquirer.prompt({
          type: "editor",
          name: "data",
          message: "Edit package",
          default: JSON.stringify(packData, null, 2)
        }).then(x => JSON.parse(x.data));
        const editProgress = ora("Editing package").start();
        editProgress.text = "Deleting package";
        await pack.deletePackage(packData);
        editProgress.text = "Adding package";
        await pack.addPackage(editData);
        editProgress.succeed("Updated package");
        continue;
      }
      throw new Error("Invalid action");
    }

    // Exit
    const exit = await inquirer.prompt({
      type: "confirm",
      name: "exit",
      message: "Do you want to exit?"
    }).then(x => x.exit);
    if (exit) return;
    // Edit another dist
    const editAnotherDist = await inquirer.prompt({
      type: "confirm",
      name: "editAnotherDist",
      message: "Do you want to edit another dist?"
    }).then(x => x.editAnotherDist);
    if (!editAnotherDist) return packEdit(dist);
    options.distribuition = undefined;
    return packEdit();
  }
  await packEdit();
  return pack.close();
})).parseAsync();