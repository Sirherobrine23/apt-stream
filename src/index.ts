#!/usr/bin/env node
import { getConfig, saveConfig } from "./repoConfig.js";
import { writeFile } from "node:fs/promises";
import openpgp from "openpgp";
import yargs from "yargs";
import path from "node:path";
import repo from "./express_route.js";
import yaml from "yaml";
import os from "node:os";
import cluster from "node:cluster";

yargs(process.argv.slice(2)).version(false).help().demandCommand().strictCommands().alias("h", "help").option("cofig-path", {
  type: "string",
  default: path.join(process.cwd(), "repoconfig.yml"),
  alias: "c",
  demandOption: false,
  description: "Default config path"
}).command("config", "maneger basics configs", async yargs => {
  return yargs.demandCommand().strictCommands().command("pgp_keys", "Generate PGP keys", async yargs => {
    const options = yargs.option("passphrase", {
      type: "string",
      default: "",
      alias: "p",
      demandOption: false,
    }).option("name", {
      type: "string",
      default: "",
      alias: "n",
      demandOption: true,
      description: "You name to register in PGP key"
    }).option("email", {
      type: "string",
      default: "",
      alias: "e",
      demandOption: true,
      description: "You email to register in PGP key"
    }).parseSync();

    const config = await getConfig(options.cofigPath);
    if (!options.email) throw new Error("email is required");
    if (!options.name) throw new Error("name is required");
    if (!options.passphrase) options.passphrase = undefined;
    const privatePath = path.resolve(path.dirname(options.cofigPath), "private.key");
    const publicPath = path.resolve(path.dirname(options.cofigPath), "public.key");
    const keys = await openpgp.generateKey({
      rsaBits: 4096,
      format: "armored",
      type: "rsa",
      passphrase: options.passphrase,
      userIDs: [{
        name: options.name,
        email: options.email,
        comment: "Generated by apt-stream"
      }],
    });
    if (!config["apt-config"]) config["apt-config"] = {};
    await writeFile(privatePath, keys.privateKey);
    await writeFile(publicPath, keys.publicKey);
    config["apt-config"].pgpKey = {passphrase: options.passphrase, private: privatePath, public: publicPath};
    console.log("PGP keys generated");
    // Private key
    console.log("Private Key:\n%s\n", keys.privateKey);
    // Public key
    console.log("Public Key:\n%s", keys.publicKey);
    await saveConfig(options.cofigPath, config);
    console.log("Config saved in '%s'", options.cofigPath);
  }).command("convert_to_base64", "Convert config to base64 to export to env or backup", async yargs => {
    const options = yargs.option("json", {
      type: "boolean",
      default: true,
      alias: "j",
      demandOption: false,
      description: "Output as JSON",
    }).option("yaml", {
      type: "boolean",
      default: false,
      alias: "y",
      demandOption: false,
      description: "Output as YAML",
    }).option("output", {
      type: "string",
      default: "",
      alias: "o",
      demandOption: false,
      description: "Save to file",
    }).parseSync();
    const config = await getConfig(options.cofigPath);
    const base64 = Buffer.from(options.json ? JSON.stringify(config) : yaml.stringify(config)).toString("base64");
    if (options.output) return writeFile(options.output, "base64:"+base64).then(() => console.log("Saved to '%s'", options.output));
    console.log("base64:%s", base64);
  });
}).command("server", "Run HTTP serber", async yargs => {
  const options = yargs.parseSync();
  const envs = Object.keys(process.env).filter(key => key.startsWith("APT_STREAM"));
  const { app, packageConfig, packageManeger } = await repo(envs.length > 0 ? `env:${envs[0]}` : options.cofigPath);
  app.all("*", ({res}) => res.status(404).json({
    error: "Endpoint not exists",
    message: "Endpoint not exists, check the documentation for more information"
  }));
  app.use((err, {}, res, {}) => {
    console.error(err);
    const stack: string = err?.stack ?? "No stack";
    res.status(400).json({
      error: "Internal Server Error",
      message: "There was an error on our part, sorry for the inconvenience",
      stack: {
        forUser: "Create issue in apt-stream repository (https://github.com/Sirherobrine23/apt-stream/issues) with value of 'forDeveloper'",
        forDeveloper: stack
      },
    });
  });
  const port = process.env.PORT ?? packageConfig["apt-config"]?.portListen ?? 3000;
  if (!(Boolean(process.env["DISABLE_CLUSTER"]))) {
    if (cluster.isWorker) {
      console.log("Worker %d running, PID: %f", cluster.worker?.id ?? "No ID", process.pid);
      app.listen(port, function() {
        console.log("Work apt Stream Port listen on %f", this.address()?.port);
      });
      return;
    }
    console.log("Work master, PID %f, starting workers ...", process.pid);
    os.cpus().forEach(() => cluster.fork());
    cluster.on("error", console.error).on("exit", (worker, code, signal: NodeJS.Signals) => {
      // if (process[Symbol.for("ts-node.register.instance")]) cluster.setupPrimary({/* Fix for ts-node */ execArgv: ["--loader", "ts-node/esm"]});
      if (signal === "SIGKILL") return console.log("Worker %d was killed", worker?.id ?? "No ID");
      else if (signal === "SIGABRT") return console.log("Worker %d was aborted", worker?.id ?? "No ID");
      else if (signal === "SIGTERM") return console.log("Worker %d was terminated", worker?.id ?? "No ID");
      console.log("Worker %d died with code: %s, Signal: %s", worker?.id ?? "No ID", code, signal ?? "No Signal");
    }).on("online", worker => console.log("Worker %d is online", worker?.id ?? "No ID"));
  } else app.listen(port, function() {console.log("Apt Stream Port listen on %f", this.address()?.port)});

  // large ram available
  if (os.freemem() > 2 * 1024 * 1024 * 1024) await Promise.all(Object.keys(packageConfig.repositories).map(async distName => {const dist = packageConfig.repositories[distName]; return Promise.all(dist.targets.map(async target => packageManeger.loadRepository(distName, target, packageConfig["apt-config"], packageConfig).catch(console.error)));})).catch(console.error);
  console.warn("Not enough RAM to load all repositories, loading one by one");
  for (const distName in packageConfig.repositories) {
    const dist = packageConfig.repositories[distName];
    for (const target of dist.targets) {
      await packageManeger.loadRepository(distName, target, packageConfig["apt-config"], packageConfig).catch(console.error);
    }
  }
}).parseAsync();