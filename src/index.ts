#!/usr/bin/env node
import { aptSConfig, repositoryFrom, configManeger, saveConfig } from "./configManeger.js";
import { promises as fs } from "node:fs";
import { format } from "node:util";
import coreUtils, { googleDriver } from "@sirherobrine23/coreutils";
import inquirer from "inquirer";
import openpgp from "openpgp";
import express from "express";
import Route from "./Route.js";
import yargs from "yargs";
import path from "node:path";
import yaml from "yaml";
import ora from "ora";
import os from "node:os";

yargs(process.argv.slice(2)).strictCommands().strict().alias("h", "help").option("config", {
  alias: "C",
  type: "string",
  default: "apts.yaml",
  description: "Path to config file"
}).command("server", "Start server", async yargs => {
  const options = yargs.strict().option("port", {
    alias: "p",
    type: "number",
    default: 3000,
    description: "Port to listen on"
  }).option("cluster", {
    description: "Number to user in cluster mode, defaults to half of the number of CPUs, to disable set to negative numbers",
    type: "number",
    alias: "c",
    default: os.cpus().length,
  }).parseSync();
  const aptRoute = await Route(options.config);
  const app = express();
  app.disable("x-powered-by").disable("etag").use(express.json()).use(express.urlencoded({ extended: true })).use(aptRoute.app);
  app.listen(options.port, () => console.log("Server started on port %s", options.port));
}).command("base64", "Convert config in base64 string", async yargs => {
  const options = yargs.strict().option("json", {
    type: "boolean",
    description: "Output as json",
    default: false,
    alias: "j"
  }).option("yaml", {
    type: "boolean",
    description: "Output as yaml",
    default: false,
    alias: [
      "y",
      "yml"
    ]
  }).option("output", {
    type: "string",
    string: true,
    description: "Output file",
    alias: "o",
    default: null,
  }).parseSync();
  const baseSring = "base64:"+(Buffer.from((options.json ? JSON.stringify : yaml.stringify)(await configManeger(options.config)), "utf8").toString("base64"));
  if (options.output) await fs.writeFile(options.output, baseSring);
  return console.log(baseSring);
}).command("config", "Config maneger", async yargs => {
  const options = yargs.strict().option("create-config", {
    type: "boolean",
    description: "Create config file",
    default: false
  }).parseSync();
  let base: Partial<aptSConfig>;
  if (options.createConfig || !await coreUtils.extendFs.exists(options.config)) {
    if (!await inquirer.prompt([{type: "confirm", name: "confirm", message: "Config file does not exist, create it?", default: true}]).then(a => a.confirm)) throw new Error("Config file does not exist");
    const initialData = await inquirer.prompt<{portListen: number, cluster: number, useDatabase: boolean, pgpGen: boolean}>([
      {
        type: "input",
        name: "portListen",
        message: "Port to listen",
        default: 3000
      },
      {
        type: "input",
        name: "cluster",
        message: "Number to user in cluster mode, defaults to half of the number of CPUs, to disable set to negative numbers",
        default: os.cpus().length,
      },
      {
        type: "confirm",
        name: "pgpGen",
        message: "Generate PGP key",
        default: true
      },
      {
        type: "confirm",
        name: "useDatabase",
        message: "Use database",
        default: true
      }
    ]);
    base = {
      repositorys: {},
      server: {
        portListen: initialData.portListen,
        cluster: initialData.cluster
      }
    };
    if (initialData.pgpGen) {
      const pgpInfo = await inquirer.prompt<{name: string, email: string, password: string}>([
        {
          type: "input",
          name: "name",
          message: "You name to use in PGP key",
          default: os.userInfo().username
        },
        {
          type: "input",
          name: "email",
          message: "You email to use in PGP key",
          default: `${os.userInfo().username}@${os.hostname()}`
        },
        {
          type: "password",
          name: "password",
          message: "Password to use in PGP key, leave blank for no password",
          default: "",
          mask: "*"
        }
      ]);
      const oraGen = ora("Generating PGP key").start();
      const key = await openpgp.generateKey({
        rsaBits: 4096,
        format: "armored",
        type: "rsa",
        passphrase: pgpInfo.password.trim() ? pgpInfo.password : undefined,
        userIDs: [{
          name: pgpInfo.name,
          email: pgpInfo.email,
          comment: "Generated by apt-stream"
        }],
      });
      oraGen.succeed("Generated PGP key");
      base.server.pgp = {
        privateKey: key.privateKey,
        publicKey: key.publicKey,
        passphrase: pgpInfo.password
      };
      // write key to file
      if (await inquirer.prompt<{write: boolean}>({type: "confirm", name: "write", message: "Write key to file?", default: true}).then(a => a.write)) {
        const keyFilesName = await inquirer.prompt<{private: string, public: string}>([
          {
            type: "input",
            name: "private",
            message: "Private key file path",
            default: path.resolve(path.dirname(options.config), "pgpPrivate.key")
          },
          {
            type: "input",
            name: "public",
            message: "Public key file path",
            default: path.resolve(path.dirname(options.config), "pgpPublic.key")
          }
        ]);
        const saveSpinner = ora("Saving key to file").start();
        const resolvedPrivate = path.resolve(keyFilesName.private);
        const resolvedPublic = path.resolve(keyFilesName.public);
        await fs.writeFile(resolvedPrivate, base.server.pgp.privateKey);
        await fs.writeFile(resolvedPublic, base.server.pgp.publicKey);
        base.server.pgp.privateKey = resolvedPrivate;
        base.server.pgp.publicKey = resolvedPublic;
        saveSpinner.succeed("Saved key to file");
      }
    }

    if (initialData.useDatabase) {
      const { dbType } = await inquirer.prompt({
        type: "list",
        name: "dbType",
        message: "Database type",
        default: "mongodb",
        choices: [
          "mongodb",
          "custom"
        ],
      });
      if (dbType === "mongodb") {
        const { mongoURL, databaseName, collectionName } = await inquirer.prompt<{mongoURL: string, databaseName: string, collectionName: string}>([
          {
            type: "input",
            name: "mongoURL",
            message: "MongoDB URL",
            default: "mongodb://localhost:27017",
            validate(input) {
              if (!input) return "Set URL, dont leave blank";
              if (!(input.startsWith("mongodb://") || input.startsWith("mongodb+srv://"))) return "Invalid URL";
              return true;
            },
          },
          {
            type: "input",
            name: "databaseName",
            message: "Database name",
            default: "apt-stream",
            validate(input) {
              if (!input) return "Set database name, dont leave blank";
              if (input.length > 24) return "Database name must be less than 24 characters";
              return true;
            }
          },
          {
            type: "input",
            name: "collectionName",
            message: "Collection name",
            default: "packagesData",
            validate(input) {
              if (!input) return "Set collection name, dont leave blank";
              if (input.length > 64) return "Collection name must be less than 64 characters";
              return true;
            }
          }
        ]);
        base.db = {
          type: "mongodb",
          url: mongoURL,
          db: databaseName,
          collection: collectionName
        };
      } else if (dbType === "custom") {} else console.warn("Invalid database type");
    }
  } else base = await configManeger(options.config);

  async function addRepository(repoName?: string) {
    if (Object.keys(base.repositorys).length === 0 || !repoName) {
      const repoNameInput = await inquirer.prompt<{name: string}>({
        type: "input",
        name: "name",
        message: "Distribuition name"
      });
      repoName = repoNameInput.name;
      base.repositorys[repoName] = {from: []};
    }
    const repoType = await inquirer.prompt({
      type: "list",
      name: "repoType",
      message: "Repository type",
      choices: [
        "local",
        "mirror",
        "http",
        "github",
        "docker",
        "google_driver",
        "oracle_bucket"
      ]
    }).then(a => a.repoType as repositoryFrom["type"]);
    console.log(repoType);
    if (repoType === "http") {
      const httpInfo = await inquirer.prompt<{url: string, requiredAuth: boolean}>([
        {
          type: "input",
          name: "url",
          message: "URL to repo",
          validate(input) {
            try {
              new URL(input);
              return true;
            } catch (err) {
              return String(err);
            }
          }
        },
        {
          type: "confirm",
          name: "requiredAuth",
          message: "Request require auth?",
          default: false
        }
      ]);
      const repo: repositoryFrom = {
        type: "http",
        url: httpInfo.url
      };
      if (httpInfo.requiredAuth) {
        const httpAuth = JSON.parse(await inquirer.prompt({
          type: "editor",
          name: "auth",
          message: "Auth data",
          default: JSON.stringify({
            headers: {},
            query: {},
          }, null, 2)
        }).then(a => a.auth));
        repo.auth = {
          header: httpAuth.headers,
          query: httpAuth.query
        };
      }
      base.repositorys[repoName].from.push(repo);
    } else if (repoType === "local") {
      const { folderPath } = await inquirer.prompt<{folderPath: string}>({
        type: "input",
        name: "folderPath",
        message: "Folder path"
      });
      if (!await coreUtils.extendFs.exists(folderPath)) throw new Error("Folder not found");
      base.repositorys[repoName].from.push({
        type: "local",
        path: folderPath
      });
    } else if (repoType === "github") {
      const { owner, repository, token, variant } = await inquirer.prompt<{owner: string, repository: string, token?: string, variant: "repo"|"release"}>([
        {
          type: "input",
          name: "owner",
          message: "Repository owner",
          validate(input) {
            if (input.length < 1) return "Owner can't be empty";
            if (input.length > 39) return "Owner can't be longer than 39 characters";
            if (input.includes("/")) return "Owner can't include /";
            return true;
          },
        },
        {
          type: "input",
          name: "repository",
          message: "Repository name",
          validate(input) {
            if (input.length < 1) return "Repository name can't be empty";
            if (input.length > 100) return "Repository name can't be longer than 100 characters";
            if (input.includes("/")) return "Repository name can't include /";
            return true;
          }
        },
        {
          type: "password",
          name: "token",
          message: "Token"
        },
        {
          type: "list",
          name: "variant",
          message: "Variant",
          default: "release",
          choices: [
            "release",
            "repo",
          ]
        },
      ]);
      if (variant === "repo") {
        const remoteBranches = await coreUtils.httpRequest.getJSON<{name: string}[]>({
          url: `https://api.github.com/repos/${owner}/${repository}/branches`,
          headers: token ? {Authorization: `Bearer ${token}`} : {}
        }).then(a => a.map(b => b.name));
        const { branch } = await inquirer.prompt<{branch: string}>({
          type: "list",
          name: "branch",
          message: "Select branch",
          choices: remoteBranches,
          default: remoteBranches.at(0)
        });
        base.repositorys[repoName].from.push({
          type: "github",
          subType: "branch",
          token,
          owner,
          repository,
          branch: branch ?? "master"
        });
      } else if (variant === "release") {
        base.repositorys[repoName].from.push({
          type: "github",
          subType: "release",
          token,
          owner,
          repository
        });
      } else throw new Error("Unknown github variant");
    } else if (repoType === "docker") {
      const { image } = await inquirer.prompt([
        {
          type: "input",
          name: "image",
          message: "Image name"
        }
      ]);
      base.repositorys[repoName].from.push({
        type: "docker",
        image
      });
    } else if (repoType === "google_driver") {
      const { client_secret, client_id } = await inquirer.prompt([
        {
          type: "input",
          name: "client_secret",
          message: "Client secret"
        },
        {
          type: "input",
          name: "client_id",
          message: "Client id"
        }
      ]);

      let inToken: string;
      const oraURL = ora("Creating url to get token").start();
      await googleDriver.GoogleDriver(client_secret, client_id, {async authCallback(url, token) {
        if (token) {
          inToken = token;
          oraURL.succeed("Token created");
          return;
        } else {
          oraURL.text = format("Open url '%s' to get token", url);
          oraURL.stop();
        }
      }});

      base.repositorys[repoName].from.push({
        type: "google_driver",
        app: {
          secret: client_secret,
          id: client_id,
          token: inToken
        }
      });
    } else if (repoType === "oracle_bucket") {
    } else if (repoType === "mirror") {
    } else throw new Error("Unknown repo type");
  }

  async function loopLoad() {
    const savingSpinner = ora("Saving config").start();
    await saveConfig(base, options.config);
    savingSpinner.succeed("Saved config");
    const distName = Object.keys(base.repositorys);
    if (distName.length === 0) {
      console.log("Init fist repository");
      return addRepository().then(() => loopLoad()).catch(() => process.exit(0));
    };
    const opte = await inquirer.prompt<{opte: string}>({
      type: "list",
      name: "opte",
      message: "Select opteration",
      default: "add",
      choices: [
        "add",
        "remove",
        "change",
        "cancel",
      ]
    });
    if (opte.opte === "add") return addRepository().then(() => loopLoad()).catch(() => process.exit(0));
    if (opte.opte === "remove") return loopLoad();
    if (opte.opte === "change") return loopLoad();
    if (opte.opte === "cancel") return;
  }
  return loopLoad();
}).command("package", "Maneger packages", yargs => yargs.strict().strictCommands().command("load", "Load packages", async yargs => {})).parseAsync();