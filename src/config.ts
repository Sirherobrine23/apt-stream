import { googleDriver, oracleBucket } from "@sirherobrine23/cloud";
import { extendsFS } from "@sirherobrine23/extends";
import { userAuth } from "@sirherobrine23/docker-registry";
import fs from "node:fs/promises";
import yaml from "yaml";
import path from "node:path";
import crypto from "node:crypto";

export type repositorySource = {
  /**
   * Dist component
   * @default main
   */
  componentName?: string,

  /**
   * ID generated by apt-stream don't create ID
   */
  id?: string,
} & ({
  type: "http",
  url: string,
  auth?: {
    header?: {[key: string]: string},
    query?: {[key: string]: string}
  }
}|{
  type: "github",
  /**
   * Repository owner
   * @example `Sirherobrine23`
   */
  owner: string,
  /**
   * Repository name
   * @example `apt-stream`
   */
  repository: string,
  /**
   * Auth token, not required if public repository
   */
  token?: string,
} & ({
  subType: "release",
  tag?: string[],
}|{
  subType: "branch",
  branch: string,
})|{
  type: "google_driver",
  clientSecret: string,
  clientId: string,
  clientToken?: googleDriver.googleCredential,
  gIds?: string[],
}|{
  type: "oracle_bucket",
  path?: string[],
  authConfig: oracleBucket.oracleOptions
}|{
  type: "docker",
  image: string,
  auth?: userAuth,
  tags?: string[]
})

export type aptStreamConfig = {
  serverConfig?: {
    /** HTTP server listen */
    portListen?: number,

    /** Run Server in cluste mode, example 8 */
    clusterCount?: number,

    cacheFolder?: string,

    logLevel?: "DEBUG"|"WARN"|"ERROR"|"SILENCE"
  },

  database: {
    drive: "mongodb",
    url: string,
    /**
     * Database name
     *
     * @default 'apt-stream'
     */
    databaseName?: string,
    /**
     * Database name
     *
     * @default 'packages'
     */
    collection?: string
  }|{
    drive: "couchdb",
    url: string,
    /**
     * Database name
     *
     * @default 'apt-stream'
     */
    databaseName?: string,
  },

  gpgSign?: {
    authPassword?: string,
    private: {path?: string, content: string},
    public: {path?: string, content: string},
  },

  repository: {
    [componentName: string]: {
      source: repositorySource[],
      aptConfig?: {
        /** Replace globalAptConfig origim if seted */
        Origin?: string,
        /** Repository lebel */
        Label?: string,
        /** Repository Codename */
        Codename?: string,
        /** Repository Version (Ubuntu) */
        Version?: string,
        /** Repository description (single line) */
        Description?: string,
      }
    }
  }

}

function returnUniq(arg: (string)[]) {return Array.from(new Set(arg));}

export async function createConfig(configPath: string) {
  let ext = ".json";
  if (path.extname(configPath) === ".yaml" || path.extname(configPath) === ".yml") ext = ".yaml";
  const tmpConfig: Partial<aptStreamConfig> = {
    serverConfig: {
      clusterCount: 0,
      portListen: 0,
      logLevel: "SILENCE"
    },
    repository: {}
  };
  return fs.writeFile(configPath, ext === ".json" ? JSON.stringify(tmpConfig, null, 2) : yaml.stringify(tmpConfig));
}

export async function prettyConfig(tmpConfig: aptStreamConfig, optionsOverload?: Partial<aptStreamConfig>) {
  const newConfigObject: aptStreamConfig = {
    serverConfig: {
      portListen: optionsOverload?.serverConfig?.portListen ?? tmpConfig.serverConfig?.portListen ?? 3000,
      clusterCount: optionsOverload?.serverConfig?.clusterCount ?? tmpConfig.serverConfig?.clusterCount ?? 0,
      logLevel: optionsOverload?.serverConfig?.logLevel ?? tmpConfig?.serverConfig?.logLevel ?? "SILENCE",
    },
    database: optionsOverload?.database ?? tmpConfig.database,
    gpgSign: (optionsOverload?.gpgSign ?? tmpConfig.gpgSign),
    repository: {},
  };

  if (newConfigObject.gpgSign) {
    if (!newConfigObject.gpgSign.private.content && newConfigObject.gpgSign.private.path) newConfigObject.gpgSign.private.content = await fs.readFile(path.resolve(process.cwd(), newConfigObject.gpgSign.private.path), "utf8");
    if (!newConfigObject.gpgSign.public.content && newConfigObject.gpgSign.public.path) newConfigObject.gpgSign.public.content = await fs.readFile(path.resolve(process.cwd(), newConfigObject.gpgSign.public.path), "utf8");
  }

  for (const repoName of returnUniq((Object.keys(optionsOverload?.repository ?? {}).concat(...(Object.keys(tmpConfig.repository ?? {})))))) {
    for (const data of ((optionsOverload?.repository?.[repoName]?.source ?? []).concat(tmpConfig?.repository?.[repoName]?.source)).filter(Boolean)) {
      if (!data) continue;
      const nName = encodeURIComponent(decodeURIComponent(repoName));
      newConfigObject.repository[nName] ??= {source: []};
      const id = String(data?.id ?? "").startsWith("aptS__") ? data.id : "aptS__"+(crypto.randomBytes(16).toString("hex"));
      if (data.type === "http") newConfigObject.repository[nName].source.push(data);
      else if (data.type === "github") {
        if (!data.owner?.trim()) throw new TypeError("github.owner is empty");
        if (!data.repository?.trim()) throw new TypeError("github.repository is empty");
        newConfigObject.repository[nName].source.push({
          type: "github",
          owner: data.owner,
          repository: data.repository,
          token: (typeof data.token === "string" && data.token.trim()) ? data.token : null,
          componentName: (typeof data.componentName === "string" && data.componentName.trim()) ? data.componentName : null,
          id,
          ...(data.subType === "release" ? {
            subType: "release",
            tag: data.tag?.filter(Boolean)
          } : {
            subType: "branch",
            branch: data.branch
          })
        });
      } else if (data.type === "oracle_bucket") {
        if (!data.authConfig) throw new TypeError("oracleBucket.authConfig required authentication");
        else if (!data.authConfig.namespace) throw new TypeError("required oracleBucket.authConfig.namespace");
        else if (!data.authConfig.name) throw new TypeError("required oracleBucket.authConfig.name");
        else if (!data.authConfig.region) throw new TypeError("required oracleBucket.authConfig.region");
        else if (!data.authConfig.auth) throw new TypeError("required oracleBucket.authConfig.auth");

        newConfigObject.repository[nName].source.push({
          type: "oracle_bucket",
          componentName: data.componentName ?? null,
          id,
          authConfig: {
            region: data.authConfig.region,
            namespace: data.authConfig.namespace,
            name: data.authConfig.name,
            auth: data.authConfig.auth,
          },
          path: data.path,
        });
      } else if (data.type === "google_driver") {
        if (!data.clientId) throw new TypeError("required googleDriver.clientId to auth");
        else if (!data.clientSecret) throw new TypeError("required googleDriver.clientSecret to auth");
        newConfigObject.repository[nName].source.push({
          type: "google_driver",
          componentName: data.componentName ?? null,
          id,
          clientId: data.clientId,
          clientSecret: data.clientSecret,
          clientToken: data.clientToken,
          gIds: (data.gIds ?? []).map(k => k?.trim()).filter(Boolean),
        });
      } else if (data.type === "docker") {
        if (!data.image) throw new TypeError("misconfigured docker image, check your docker.image");
        newConfigObject.repository[nName].source.push({
          type: "docker",
          componentName: data.componentName ?? null,
          id,
          image: data.image,
          auth: data.auth ? {username: data.auth!.username, password: data.auth!.password} : undefined,
          tags: data.tags instanceof Array ? data.tags.map(String) : [],
        });
      }
    }
  }

  return newConfigObject;
}

export async function convertString(config: aptStreamConfig, target: "yaml"|"yml"|"json"|"json64"|"yaml64"|"yml64") {
  config = await prettyConfig(config);
  let encode64 = target.endsWith("64");
  let configString: string;
  if (target === "json"||target === "json64") configString = JSON.stringify(config, null, encode64 ? 0 : 2);
  else configString = yaml.stringify(config);
  if (encode64) return Buffer.from(configString, "utf8").toString("base64");
  return configString;
}

export async function save(configPath: string, config: aptStreamConfig) {
  config = await prettyConfig(config);
  if (config.gpgSign) {
    if (config.gpgSign.private.path) {
      await fs.writeFile(path.resolve(process.cwd(), config.gpgSign.private.path), config.gpgSign.private.content);
      config.gpgSign.private.content = null;
    }
    if (config.gpgSign.public.path) {
      await fs.writeFile(path.resolve(process.cwd(), config.gpgSign.public.path), config.gpgSign.public.content);
      config.gpgSign.public.content = null;
    }
  }
  let ext = ".json";
  if (path.extname(configPath) === ".yaml" || path.extname(configPath) === ".yml") ext = ".yaml";
  return fs.writeFile(configPath, ext === ".json" ? JSON.stringify(config, null, 2) : yaml.stringify(config));
}

export async function config(configPath: string, optionsOverload?: Partial<aptStreamConfig>) {
  optionsOverload ??= {};
  if (!(await extendsFS.exists(configPath))) await createConfig(configPath);
  let tmpConfig: aptStreamConfig;
  if (configPath.endsWith(".json")) tmpConfig = JSON.parse(await fs.readFile(configPath, "utf8"));
  else if (configPath.endsWith(".yaml")||configPath.endsWith(".yml")) tmpConfig = yaml.parse(await fs.readFile(configPath, "utf8"));
  else {
    const fileContent = await fs.readFile(configPath, "utf8");
    try {
      tmpConfig = JSON.parse(fileContent);
    } catch {
      try {
        tmpConfig = yaml.parse(fileContent);
      } catch {
        throw new TypeError("Check file is JSON or YAML file format!");
      }
    }
  }

  // Create new Object
  return prettyConfig(tmpConfig, optionsOverload);
}